<!doctype html>
<head>
	<title>Journal</title>
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<meta name="theme-color" content="#ffffff">
	<link href="app.css" rel="stylesheet" type="text/css">
</head>
<body>

<article class="entry cell"><blockquote>The human mind has a limited capacity. That capacity is best used as an index to the library to get the necessary detail. It makes no sense to waste that capacity on detail, when an index is all we need in a world overflowing with detailed content when needed.</blockquote></article>
<article class="entry cell"><p>ate lunch, played piano</p></article>
<article class="passage-of-time cell"><hr></article>
<article class="entry cell"><p>Alright, so I'm gonna make a journal app.</p></article>
<article class="entry cell"><p>Here's the first bit of CSS:</p></article>
<article class="entry cell"><code>body {
	font-family: sans-serif;
	margin: 0 auto;
	max-width: 70em;
}</code></article>

<article class="entry cell"><p>Testing out a <code>bit_of(code)</code></p></article>
<article class="entry cell"><p>Note: this is not going to be a Markdown journal! Hopefully.</p></article>
<article class="entry cell"><p>ugh, <code>contenteditable</code> is shit. adding a new line and then backspacing it is increasing the font size</p></article>
<article class="entry cell"><p>and I can probably "fix" it by changing how I specify the font size (like maybe rems instead of ems)
but it's ridiculous; I'm doing it in a completely reasonable way.</p></article>
<article class="entry cell"><p>yep, using <code>rem</code> "fixes it"</p></article>
<article class="entry cell"><p>here's a link to <a href="https://www.example.com/">https://www.example.com/</a></p></article>
<article class="entry cell"><p>I'm hungry</p></article>

<article class="entry cell"><p><~10:54> got enter working</p></article>
<article class="entry cell"><p>11:07 okay time to do backspace (and then maybe delete)</p></article>
<article class="entry cell"><p>11:15 enter doesn't seem to always delete the contents of the selection, and it doesn't seem to work at the start of a non-empty cell</p></article>
<article class="entry cell"><p>11:16 or at the end, sometimes</p></article>
<article class="entry cell"><p>and it seems to alternately focus nothing or create a new cell and focus it</p></article>
<article class="entry cell"><p>11:24 oh god, every other cell contains a cell inside it</p></article>
<article class="entry cell"><p>probably because the range has to have an element when doing cloneContents()</p></article>
<article class="entry cell"><p>11:25 so maybe I'll add a check for if the range is collapsed</p></article>
<article class="entry cell"><p>11:27 hm, that doesn't help</p></article>
<article class="entry cell"><p>maybe I can create a DocumentFragment</p></article>
<article class="entry cell"><p>maybe that'll have the same problems</p></article>
<article class="entry cell"><p>11:30 um...</p></article>
<article class="entry cell"><p>11:35 oh, goddammit man</p></article>
<article class="entry cell"><code>							# new_cell.appendChild range.cloneContents()
							# new_cell.appendChild range.extractContents()
							console.log range.extractContents().children
							range.deleteContents()</code></article>
<article class="entry cell"><p>11:36 it was logging [] because extractContents removes the contents from the range</p></article>
<article class="entry cell"><p>11:37 but it is</p></article>
<article class="entry cell"><p>11:38 both methods give me the parent element along with it</p></article>
<article class="entry cell"><p>11:39 so I'll have to manually deal with it</p></article>
<article class="entry cell"><p>11:45 still not totally working</p></article>

<article class="entry cell"><code>							# new_cell.appendChild range.cloneContents()
							# new_cell.appendChild range.extractContents()
							# console.log range.extractContents().children
							# console.log (a = range.extractContents()).children
							# new_cell.appendChild a
							# contents = range.cloneContents()
							# if contents.children[0].classList.contains "cell"
							# 	contents = contents.children[0].children
							# new_cell.appendChild contents
							{children} = range.cloneContents()
							[{children}] = children if children[0]?.classList.contains "cell"
							new_cell.appendChild child for child in children
							range.deleteContents()</code></article>

<article class="entry cell"><p>contenteditable is the worst</p></article>

<article class="entry cell"><p>12:00 to be clear, it's no longer putting <code>.cell</code>s inside <code>.cell</code>s</p></article>
<article class="entry cell"><p>but it's having the same effective problem where it doesn't get focused</p></article>
<article class="entry cell"><p>12:01 I don't even know what's up with that</p></article>
<article class="entry cell"><p>it happens in less cases now (once instead of alternately after hitting enter after a line)</p></article>
<article class="entry cell"><p>but it probably now has other problems, who knows</p></article>
<article class="entry cell"><p>12:02 It's the worst.</p></article>
<article class="entry cell"><p>I'm going to bed.</p></article>

<article class="passage-of-time cell"><hr></article>

<article class="entry cell"><p>6:42 AM 3/28/2016 woke</p></article>
<article class="entry cell"><p>6:57 okay so I got the "focusing" working by giving <code>.cell &gt; p</code> a <code>min-height</code></p></article>
<article class="entry cell"><p>it was actually taking up no space in a weird way when the cell had a paragraph but the paragraph was empty</p></article>
<article class="entry cell"><p>6:59 (and we do want a paragraph)</p></article>
<article class="entry cell"><p>7:19 made it so you can follow links</p></article>
<article class="entry cell"><p>7:50 okay so deleting</p></article>
<article class="entry cell"><p>7:52 so can I use <code>range.comparePoint</code> (or <code>range.compareBoundaryPoints</code>),</p></article>
<article class="entry cell"><p>or will it only work when it's within the same exact container element?</p></article>
<article class="entry cell"><p>8:25 okay, I had to write this horrible loop, but I got it to work at first look</p></article>
<article class="entry cell"><p>8:46 it's not really working</p></article>
<article class="entry cell"><p>but I just added a border to <code>.cell</code>s and now I can actually see what's going on</p></article>
<article class="entry cell"><p>it's deleting the cell and merging the contents into the previous one</p></article>
<article class="entry cell"><p>but it's copying a line break – well, a paragraph – into the previous cell</p></article>
<article class="entry cell"><p>so it looks like it's not joining the cells (if you can't see the borders!)</p></article>
<article class="entry cell"><p>9:04 *sigh* why am I doing any of this?</p></article>
<article class="entry cell"><p>it's not like it'll be able to merge blocks of different types when you BS/del</p></article>
<article class="entry cell"><p>9:05 I should be able to– I was thinking I needed to have–</p></article>
<article class="entry cell"><p>9:06 ugh, I'm doing this because I want to be able to display timestamps at the paragraph level</p></article>
<article class="entry cell"><p>9:08 is it worth it, though? probably not</p></article>
<article class="entry cell"><p>9:09 I can probably get away with a prebuilt contenteditor (assuming I can find a good solid one)</p></article>
<article class="entry cell"><p>just let you write multiple paragraphs of text without 9:10 adding tons of timestamps</p></article>
<article class="entry cell"><p>and when you switch back to the app, it'll have a new cell for you?</p></article>
<article class="entry cell"><p>9:11 not sure how that would work exactly</p></article>
<article class="entry cell"><p>9:20 nope nope nope:</p></article>

<article class="entry cell"><code>					previous_cell = cell.previousSibling
					if previous_cell?
						until previous_cell.nodeType is Node.ELEMENT_NODE
							previous_cell = previous_cell.previousSibling</code></article>

<article class="entry cell"><p>this:</p></article>
<article class="entry cell"><code>	previous_cell = cell.previousElementSibling</code></article>

<article class="entry cell"><p>9:23 oh! I need to make the element contenteditable before I can place the cursor in it, duh</p></article>
<article class="entry cell"><p>9:25 now I just need to remove the break between paragraphs when merging</p></article>
<article class="entry cell"><p>and ensure there's a paragraph when splitting</p></article>
<article class="entry cell"><p>(or maybe not use paragraphs within the cells?)</p></article>
<article class="entry cell"><p>9:27 omg contenteditable is the worst</p></article>
<article class="entry cell"><p>I just found a scenario (that I probably can't reproduce) where I absolutely could not delete a paragraph break/empty paragraph</p></article>
<article class="entry cell"><p>9:28 so I did Ctrl+A within the cell and hit delete and it deleted all the text but the cell got taller</p></article>
<article class="entry cell"><p>and subsequent deletes expanded the cell</p></article>
<article class="entry cell"><p>like</p></article>
<article class="entry cell"><p>wtf</p></article>
<article class="entry cell"><p>9:29 there's no way I can fully tame this beast, this piece of shit, this ridiculous febautugre</p></article>
<article class="entry cell"><p>10:28 <a href="https://msdn.microsoft.com/en-us/library/ms533071%28VS.85%29.aspx?f=255&amp;MSPPError=-2147217396">https://msdn.microsoft.com/en-us/library/ms533071%28VS.85%29.aspx?f=255&amp;MSPPError=-2147217396</a> This property should be marked as deprecated, and the phrase "all browsers <i>should</i> recognize" is somewhat ridiculous in this scenario.</p></article>
<article class="entry cell"><p>10:43 can't really inspect range objects by logging them because they fricking change</p></article>
<article class="entry cell"><p>10:46 okay, I'm gonna move this check to near the top of backspace handling:</p></article>

<article class="entry cell"><code>					previous_cell = cell.previousElementSibling
					if previous_cell?</code></article>
					
<article class="entry cell"><p>and add a check for the previous cell being a .entry cell</p></article>

<article class="entry cell"><p>11:02 this doesn't really work:</p></article>
<article class="entry cell"><code>						frag = document.createDocumentFragment()
						{children} = cell
						{children} = children[0] if children[0]?.tagName is "P"
						for child in children
							frag.appendChild child if child?</code></article>
<article class="entry cell"><p>I think I need to do...</p></article>
<article class="entry cell"><p>11:04 no wait, this isn't going to work:</p></article>
<article class="entry cell"><code>						frag = document.createDocumentFragment()
						{children} = cell
						for child in children
							if child?.tagName is "P"
								for grandkid in child.children
									frag.appendChild grandkid if grandkid?
							else
								frag.appendChild child if child?
						
						cell.parentElement.removeChild cell
						previous_cell.appendChild frag</code></article>
<article class="entry cell"><p>I need to put the stuff in a first child paragraph if any within a last child paragraph of the previous cell if any</p></article>
<article class="entry cell"><p>and put the rest of the stuff at the end as elements</p></article>

<article class="entry cell"><p>11:37 you would think this would work:</p></article>

<article class="entry cell"><code>						children = Array.from cell.children
						
						# if the previous cell's last element and this cell's first element are both paragraphs
						previous_cell_last_el = previous_cell.children[previous_cell.children.length - 1]
						if previous_cell_last_el.tagName is "P" and children[0].tagName is "P"
							console.log "got two paragraphs to merge"
							p = children.shift()
							merge_into_p = previous_cell_last_el
							console.log p, p.children
							for child in p.children
								frag.appendChild child if child?
							frag = document.createDocumentFragment()
							console.log "merging", frag.children, "from", p, "into", merge_into_p
							merge_into_p.appendChild frag
						
						frag = document.createDocumentFragment()
						
						for child in children
							if child?.tagName is "P"
								for grandkid in child.children
									frag.appendChild grandkid if grandkid?
							else
								frag.appendChild child if child?
						
						cell.parentElement.removeChild cell
						previous_cell.appendChild frag</code></article>

<article class="entry cell"><p>but when I <code>console.log p, p.children</code></p></article>
<article class="entry cell"><p>do you know what I get in the console?</p></article>
<article class="entry cell"><p>a <code>&lt;p&gt;</code> with a textnode and some content, and oh bloody hell I need to use childNodes instead of children</p></article>
<article class="entry cell"><p>11:21 probably everywhere</p></article>
<article class="entry cell"><p>11:22 the assumsion I was going on was that since you have to use previousElementSibling instead of previousSibling when you want to deal in elements that it would not BE REVERSED WHEN ACESSING CHILDREN AS OPPOSED TO SIBLINGS</p></article>
<article class="entry cell"><p>11:23 but anyways</p></article>
<article class="entry cell"><p>11:29 okay, and then I just need to fix checking whether we're at the start of a cell or not</p></article>
<article class="entry cell"><p>I got rid of <code>and range.startOffset is 0</code> from here:</p></article>
<article class="entry cell"><code>							if range.collapsed # and range.startOffset is 0</code></article>
<article class="entry cell"><p>because it doesn't always work</p></article>
<article class="entry cell"><p>because the offset can be an offset of elements</p></article>
<article class="entry cell"><p>which can be empty and (should be) inconsequential</p></article>
<article class="entry cell"><p>11:42 okay!</p></article>
<article class="entry cell"><code>							if range.collapsed # and range.startOffset is 0
								if range.startContainer.nodeType is Node.ELEMENT_NODE
									# note: not very solid logic just checking innerHTML on one element
									if range.startOffset > 0 and range.startContainer.children[range.startOffset - 1].innerHTML
										continue # as in, don't continue
								else
									if range.startOffset > 0
										continue # as in, don't continue</code></article>

<article class="entry cell"><p>that's bloody awful code, but it works!*</p></article>
<article class="entry cell from-future"><p>*in some cases, as noted in the code</p></article>
<article class="entry cell"><p>now I just ("just", I mean come on) need to ensure paragraphs exist in new cells</p></article>

<article class="entry cell"><p>11:48 god, it is not a solid thing at all
<article class="entry cell"><p>there's just</p></article>
<article class="entry cell"><p>there's just <b>infinite edge cases</b></p></article>
<article class="entry cell"><p>and it sucks</p></article>
<article class="entry cell"><p>it friggin sucks</p></article>
<article class="entry cell"><p>11:49 I'm gonna lie down</p></article>
<article class="entry cell"><p>12:06 ghdfgh</p></article>
<article class="entry cell"><p>1:00 not sure why I just spent the time to convert all of the above</p></article>
<article class="entry cell"><p>not writing a conversion tool instead</p></article>

	<article class="entry cell" contenteditable></article>
	<script src="lib/coffee-script.js"></script>
	<script src="app.coffee" type="text/coffeescript"></script>
</body>
